import discord
from asyncio import sleep
from datetime import datetime
from glob import glob

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from discord import Embed, File, Intents
from discord.ext.commands import Bot as BotBase
from discord.ext.commands import CommandNotFound

from ..db import db

PREFIX = "+"
OWNER_IDS = [134118092082118657]
COGS = [path.split("\\")[-1][:-3] for path in glob("./lib/cogs/*.py")]


class Ready(object):
    def __init__(self):
        for cog in COGS:
            setattr(self, cog, False)

    def ready_up(self, cog):
        setattr(self, cog, True)
        print(f" {cog} cog ready")

    def all_ready(self):
        return all([getattr(self, cog) for cog in COGS])


class Bot(BotBase):
    def __init__(self):
        self.PREFIX = PREFIX
        self.ready = False
        self.cogs_ready = Ready()
        self.guild = None
        self.scheduler = AsyncIOScheduler()

        db.autosave(self.scheduler)

        super().__init__(
            command_prefix=PREFIX,
            owner_ids=OWNER_IDS,
            intents=Intents.all(),
        )

    def setup(self):
        for cog in COGS:
            self.load_extension(f"lib.cogs.{cog}")
            print(f"{cog} cog loaded")

        print("setup complete")

    def run(self, version):
        self.VERSION = version

        print("running setup...")
        self.setup()

        with open("./lib/bot/token.0", "r", encoding="utf-8") as tf:
            self.TOKEN = tf.read()

        print("running bot...")
        super().run(self.TOKEN, reconnect=True)

    async def rules_reminder(self):
        await self.stdout.send("Remember to adhere to the rules!")

    async def on_connect(self):
        print("bot connected")

    async def on_disconnect(self):
        print("bot disconnected")

    async def on_error(self, err, *args, **kwargs):
        if err == "on_command_error":
            await args[0].send("Something went wrong.")

        print("An error occured.")  # Catches any error.
        raise  # type: ignore

    async def on_command_error(self, ctx, exc):
        if isinstance(exc, CommandNotFound):
            pass

        else:
            raise exc.original

    async def on_ready(self):
        if not self.ready:
            self.guild = self.get_guild(663234840530780170)
            self.stdout = self.get_channel(796934983049543691)
            self.scheduler.add_job(
                self.rules_reminder,
                CronTrigger(day_of_week=0, hour=12, minute=0, second=0))
            self.scheduler.start()

            # embed = Embed(title="Now online!", description="Citadel is now online.",
            # 			  colour=0xFF0000, timestamp=datetime.utcnow())
            # fields = [("Name", "Value", True),
            # 		  ("Another field", "This field is next to the other one.", True),
            # 		  ("A non-inline field", "This field will appear on it's own row.", False)]
            # for name, value, inline in fields:
            # 	embed.add_field(name=name, value=value, inline=inline)
            # embed.set_author(name="Citadel", icon_url=self.guild.icon_url)
            # embed.set_footer(text="This is a footer!")
            # await channel.send(embed=embed)

            # await channel.send(file=File("./data/images/Mtvoq7M.jpg"))
            while not self.cogs_ready.all_ready():
                await sleep(0.5)

            await self.stdout.send("Now online!")
            self.ready = True
            print(" bot ready")

        else:
            print("bot reconnected")

    async def on_message(self, message):
        # word_list = ['cheat', 'cheats', 'hack', 'hacks',
        #             'internal', 'external', 'ddos', 'denial of service']
        # with open("data\lists\default_blacklist.txt") as f:
        # content = f.readlines()

        # don't respond to ourselves
        if message.author == self.user:
            return

        # Default Banned Websites
        # Will Be Database Somepoint.
        default_blacklist = open("data\lists\default_blacklist.txt")
        default_blacklist = [l.rstrip("\n") for l in default_blacklist]
        messageContent = message.content.lower().split()
        messageContent = messageContent

        # Default Discord Invite URLs
        # Will Be Database Somepoint.
        discord_links = open("data\lists\discord_links.txt")
        discord_links = [l.rstrip("\n") for l in discord_links]
        print(discord_links)

        if set(message.content.lower().split()) & set(default_blacklist):
            if len(default_blacklist) > 0:
                for word in default_blacklist:
                    if word in messageContent:
                        try:
                            await message.delete()
                            await message.channel.send('You sent blacklisted word :(')
                        except Exception as e:
                            print(
                                "Failed to delete a blacklisted word! Check Permissions")

    # this is wonky    if set(message.content.lower().split("/")[-2:]) & set(discord_links):
            if len(discord_links) > 0:
                for word in discord_links:
                    if word in messageContent:
                        try:
                            await message.delete()
                            await message.channel.send('You may not sent Invite URLs here.')
                        except Exception as e:
                            print("Failed to delete a link! Check Permissions")
            # Logs Deleted Messages
            if message.author.id == client.user.id:
                embed = discord.Embed(title="{} deleted a message".format(
                    message.member.name), description="", color="Blue")
                embed.add_field(name=message.content,
                                value="This is the message that he has deleted", inline=True)
                channel = client.get_channel(798324364301959169)
            await channel.send(channel, embed=embed)
            print(message.author.id)

        # Prevents the sending of commonly maliously file extensions.
        # Clean this up later with a local list...
        messageattachments = message.attachments
        if len(messageattachments) > 0:
            for attachment in messageattachments:
                if attachment.filename.endswith(".dll"):
                    await message.delete()
                    await message.channel.send("No DLL's allowed!")
                elif attachment.filename.endswith('.exe'):
                    await message.delete()
                    await message.channel.send("No EXE's allowed!")
                elif attachment.filename.endswith('.dmg'):
                    await message.delete()
                    await message.channel.send("No DMG's allowed!")
                else:
                    break


client = discord.Client()

"""
@client.event
async def on_message_delete(message):
    if message.author.id == client.user.id:
        embed = discord.Embed(title="{} deleted a message".format(
            message.member.name), description="", color="Blue")
        embed.add_field(name=message.content,
                        value="This is the message that he has deleted", inline=True)
    channel = client.get_channel(798324364301959169)
    await channel.send(channel, embed=embed)
"""

bot = Bot()








--------------



            # embed = Embed(title="Now online!", description="Citadel is now online.",
            # 			  colour=0xFF0000, timestamp=datetime.utcnow())
            # fields = [("Name", "Value", True),
            # 		  ("Another field", "This field is next to the other one.", True),
            # 		  ("A non-inline field", "This field will appear on it's own row.", False)]
            # for name, value, inline in fields:
            # 	embed.add_field(name=name, value=value, inline=inline)
            # embed.set_author(name="Citadel", icon_url=self.guild.icon_url)
            # embed.set_footer(text="This is a footer!")
            # await channel.send(embed=embed)

            # await channel.send(file=File("./data/images/Mtvoq7M.jpg"))
